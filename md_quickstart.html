<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OpenRAND: A Quick Introduction to OpenRAND</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OpenRAND
   &#160;<span id="projectnumber">0.9</span>
   </div>
   <div id="projectbrief">OpenRAND: A C++ Library for Reproducible Random Number Generation in Parallel Computing Environments</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">A Quick Introduction to OpenRAND </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>OpenRAND comes with four generator classes: <code>Phillox</code>, <code>Tyche</code>, <code>Threefry</code> and <code>Squares</code>. They all have a similar interface: given a <code>seed</code> and <code>counter</code>, the generator can produce a stream of random numbers (upto 2^32 numbers per object). <code>seed</code> should be self-explanatory, we'll introduce <code>counter</code> later.</p>
<div class="fragment"><div class="line">#include &lt;phillox.h&gt;</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">    using RNG = Phillox; // You can swap with Tyche, Threefry or Squares</div>
<div class="line">    </div>
<div class="line">    // Initialize RNG with seed and counter</div>
<div class="line">    RNG rng(/*seed*/ 42, /*counter*/ 0);</div>
<div class="line"> </div>
<div class="line">    for(int i=0; i&lt;(2&lt;&lt;31); i++){</div>
<div class="line">        // Draw an integer from uniform distribution</div>
<div class="line">        int a = rng.rand&lt;int&gt;();</div>
<div class="line">    }</div>
<div class="line">    ...</div>
<div class="line">}</div>
</div><!-- fragment --><p>You can also draw random numbers of other types, such as <code>long long int</code>, <code>double</code>, <code>float</code>, etc.</p>
<div class="fragment"><div class="line">...</div>
<div class="line">for(int i=0; i&lt;(2&lt;&lt;31); i++){</div>
<div class="line">    auto b = rng.rand&lt;long long int&gt;();</div>
<div class="line">    double c = rng.rand&lt;double&gt;();</div>
<div class="line">    float f = rng.rand&lt;float&gt;();</div>
<div class="line">}</div>
<div class="line">...</div>
</div><!-- fragment --><p>The API follows numpy style. If you want a floating point from a normal distribution, use <code>randn</code>:</p>
<div class="fragment"><div class="line">...</div>
<div class="line">auto f = rng.randn&lt;float&gt;();</div>
<div class="line"> </div>
<div class="line">// A double with mean 10 and standard deviation 5</div>
<div class="line">auto d = rng.randn&lt;double&gt;(10.0, 5.0);</div>
</div><!-- fragment --><p>You can pair these generators seamlessly with the built-in distribution functions from C++'s &lt;random&gt; library:</p>
<div class="fragment"><div class="line">RNG rng(12345, 1);</div>
<div class="line">std::normal_distribution&lt;double&gt; dist(0.0, 1.0);</div>
<div class="line">double x = dist(rng);</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md8"></a>
Parallel Streams</h1>
<p>In a parellel program, it's a good idea to let all your threads have their local random streams. In an OpenMP program you can -</p>
<div class="fragment"><div class="line">#pragma omp parallel</div>
<div class="line">{</div>
<div class="line">    int seed = omp_get_thread_num();</div>
<div class="line">    RNG gen(seed, 0);</div>
<div class="line"> </div>
<div class="line">    int hits = 0;</div>
<div class="line">    for (int i = 0; i &lt; nsamples; i++) {</div>
<div class="line">        float x = gen.rand(); // default template parameter is float in range [0,1).</div>
<div class="line">        ...</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p> Make sure the seeds are unique, OpenRAND will ensure these streams will not have any correlation between them. This is an important property of OpenRAND that sets it apart from many libraries out there.</p>
<p>Another thing to remember is that these generator objects are very cheap to create, destroy and have a very small memory footprint. So don't worry about creating a new generator object for each thread even if you've got a million threads. Which brings us to-</p>
<h1><a class="anchor" id="autotoc_md9"></a>
GPU</h1>
<p>It's time to introduce the <code>counter</code> argument.</p>
<p>You can think of a single <code>seed</code> capable of producing a unique stream of length 2^64. This stream is divided into 2^32 <em>substreams</em>, each of length 2^32. The <code>counter</code> argument is used to select a substream.</p>
<p>For reproducibility, on GPU, it's better to think in terms of work-unit or processing element instead of thread. For example, in a history-based simulation, a work-unit models the entire lifespan of one particle. In a ray tracing renderer, it can be a pixel index. A work-unit can undergo multiple kerel launches in it's lifetime.</p>
<p>One random number stream per work-item isn't ideal, it's often better to have a unique stream at each kernel launch for a work-item. In this way, you can avoid the overhead of a seperate kernel launch just to initialize random states, loading them from global memory inside each kernel, and saving back the modified state etc. <code>counter</code> helps you get around all that, by cheaply creating a substream for each kernel launch.</p>
<p>Here's an example of a typical use-case on GPU: a monte carlo paticle simulation code that runs for 10,000 time steps. We can simply use the iteration number as <code>counter</code>. For <code>seed</code>, we assume each thread below has a unique global id atribute called <code>pid</code>.</p>
<div class="fragment"><div class="line">__global__ </div>
<div class="line">void apply_forces(Particle *particles, int counter){</div>
<div class="line">    int i = blockIdx.x * blockDim.x + threadIdx.x;</div>
<div class="line">    Particle p = particles[i];</div>
<div class="line">    ...</div>
<div class="line"> </div>
<div class="line">    // create thread-local rng object</div>
<div class="line">    RNG local_rand_state(p.pid, counter);</div>
<div class="line">    </div>
<div class="line">    p.vx += (local_rand_state.rand&lt;double&gt;()  * 2.0 - 1.0);</div>
<div class="line">    ...</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">int main(){</div>
<div class="line">    ...</div>
<div class="line"> </div>
<div class="line">    // Simulation loop</div>
<div class="line">    int iter = 0;</div>
<div class="line">    while (iter++ &lt; STEPS) {</div>
<div class="line">        apply_forces&lt;&lt;&lt;nblocks, nthreads&gt;&gt;&gt;(particles, iter);</div>
<div class="line">        ...</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Interestingly, notice we've spent 0 bits of global memory to keep track of the random number states. In theory, you will need about 96 bits of memory (64 bit seed + 32 bit counter) per work-item to maintain the state of a random number generator. This is already pretty small. But we expect that in majoriy of cases, like the example above, even that won't be necessary. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
